#region OPEN SOURCE AGREEMENT
/*
	NASA OPEN SOURCE AGREEMENT VERSION 1.3

	THIS OPEN SOURCE AGREEMENT ("AGREEMENT") DEFINES THE RIGHTS OF USE,
	REPRODUCTION, DISTRIBUTION, MODIFICATION AND REDISTRIBUTION OF CERTAIN
	COMPUTER SOFTWARE ORIGINALLY RELEASED BY THE UNITED STATES GOVERNMENT
	AS REPRESENTED BY THE GOVERNMENT AGENCY LISTED BELOW ("GOVERNMENT
	AGENCY").  THE UNITED STATES GOVERNMENT, AS REPRESENTED BY GOVERNMENT
	AGENCY, IS AN INTENDED THIRD-PARTY BENEFICIARY OF ALL SUBSEQUENT
	DISTRIBUTIONS OR REDISTRIBUTIONS OF THE SUBJECT SOFTWARE.  ANYONE WHO
	USES, REPRODUCES, DISTRIBUTES, MODIFIES OR REDISTRIBUTES THE SUBJECT
	SOFTWARE, AS DEFINED HEREIN, OR ANY PART THEREOF, IS, BY THAT ACTION,
	ACCEPTING IN FULL THE RESPONSIBILITIES AND OBLIGATIONS CONTAINED IN
	THIS AGREEMENT.

	Government Agency: NASA_____________________________________
	Government Agency Original Software Designation: ______________
	Government Agency Original Software Title: ____________________
	User Registration Requested.  Please Visit http://__________________
	Government Agency Point of Contact for Original Software: ___________________
	________________________________________________


	1. DEFINITIONS

	A. "Contributor" means Government Agency, as the developer of the
	Original Software, and any entity that makes a Modification.
	B. "Covered Patents" mean patent claims licensable by a Contributor
	that are necessarily infringed by the use or sale of its Modification
	alone or when combined with the Subject Software.
	C. "Display" means the showing of a copy of the Subject Software,
	either directly or by means of an image, or any other device.
	D. "Distribution" means conveyance or transfer of the Subject
	Software, regardless of means, to another.
	E. "Larger Work" means computer software that combines Subject
	Software, or portions thereof, with software separate from the Subject
	Software that is not governed by the terms of this Agreement.
	F.  "Modification" means any alteration of, including addition to or
	deletion from, the substance or structure of either the Original
	Software or Subject Software, and includes derivative works, as that
	term is defined in the Copyright Statute, 17 USC 101.  However, the
	act of including Subject Software as part of a Larger Work does not in
	and of itself constitute a Modification.
	G. "Original Software" means the computer software first released
	under this Agreement by Government Agency with Government Agency
	designation ______________ and entitled
	_____________________________________________, including source code,
	object code and accompanying documentation, if any.
	H. "Recipient" means anyone who acquires the Subject Software under
	this Agreement, including all Contributors.
	I. "Redistribution" means Distribution of the Subject Software after a
	Modification has been made.
	J. "Reproduction" means the making of a counterpart, image or copy of
	the Subject Software.
	K. "Sale" means the exchange of the Subject Software for money or
	equivalent value.
	L. "Subject Software" means the Original Software, Modifications, or
	any respective parts thereof.
	M. "Use" means the application or employment of the Subject Software
	for any purpose.

	2. GRANT OF RIGHTS

	A. Under Non-Patent Rights: Subject to the terms and conditions of
	this Agreement, each Contributor, with respect to its own contribution
	to the Subject Software, hereby grants to each Recipient a
	non-exclusive, world-wide, royalty-free license to engage in the
	following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Modification
	5. Redistribution
	6. Display

	B. Under Patent Rights: Subject to the terms and conditions of this
	Agreement, each Contributor, with respect to its own contribution to
	the Subject Software, hereby grants to each Recipient under Covered
	Patents a non-exclusive, world-wide, royalty-free license to engage in
	the following activities pertaining to the Subject Software:

	1. Use
	2. Distribution
	3. Reproduction
	4. Sale
	5. Offer for Sale

	C. The rights granted under Paragraph B. also apply to the combination
	of a Contributor's Modification and the Subject Software if, at the
	time the Modification is added by the Contributor, the addition of
	such Modification causes the combination to be covered by the Covered
	Patents.  It does not apply to any other combinations that include a
	Modification.

	D. The rights granted in Paragraphs A. and B. allow the Recipient to
	sublicense those same rights.  Such sublicense must be under the same
	terms and conditions of this Agreement.

	3. OBLIGATIONS OF RECIPIENT

	A. Distribution or Redistribution of the Subject Software must be made
	under this Agreement except for additions covered under paragraph 3H.

	1. Whenever a Recipient distributes or redistributes the Subject
	Software, a copy of this Agreement must be included with each copy
	of the Subject Software; and
	2. If Recipient distributes or redistributes the Subject Software in
	any form other than source code, Recipient must also make the
	source code freely available, and must provide with each copy of
	the Subject Software information on how to obtain the source code
	in a reasonable manner on or through a medium customarily used for
	software exchange.

	B. Each Recipient must ensure that the following copyright notice
	appears prominently in the Subject Software:

	[Government Agency will insert the applicable copyright notice in each
	agreement accompanying the initial distribution of original software
	and remove this bracketed language.]

	[The following copyright notice will be used if created by a
	contractor pursuant to Government Agency contract and rights obtained
	from creator by assignment.  Government Agency will insert the year
	and its Agency designation and remove the bracketed language.]
	Copyright  {YEAR} United States Government as represented by ______
	_________________________.  All Rights Reserved.

	[The following copyright notice will be used if created by civil
	servants only. Government Agency will insert the year and its Agency
	designation and remove the bracketed language.]  Copyright � {YEAR}
	United States Government as represented by _____________
	_____________________________.  No copyright is claimed in the United
	States under Title 17, U.S.Code. All Other Rights Reserved.

	C. Each Contributor must characterize its alteration of the Subject
	Software as a Modification and must identify itself as the originator
	of its Modification in a manner that reasonably allows subsequent
	Recipients to identify the originator of the Modification.  In
	fulfillment of these requirements, Contributor must include a file
	(e.g., a change log file) that describes the alterations made and the
	date of the alterations, identifies Contributor as originator of the
	alterations, and consents to characterization of the alterations as a
	Modification, for example, by including a statement that the
	Modification is derived, directly or indirectly, from Original
	Software provided by Government Agency. Once consent is granted, it
	may not thereafter be revoked.

	D. A Contributor may add its own copyright notice to the Subject
	Software.  Once a copyright notice has been added to the Subject
	Software, a Recipient may not remove it without the express permission
	of the Contributor who added the notice.

	E. A Recipient may not make any representation in the Subject Software
	or in any promotional, advertising or other material that may be
	construed as an endorsement by Government Agency or by any prior
	Recipient of any product or service provided by Recipient, or that may
	seek to obtain commercial advantage by the fact of Government Agency's
	or a prior Recipient's participation in this Agreement.

	F. In an effort to track usage and maintain accurate records of the
	Subject Software, each Recipient, upon receipt of the Subject
	Software, is requested to register with Government Agency by visiting
	the following website: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency at the web site provided
	above how to access the Modification.

	[Alternative paragraph for use when a web site for release and
	monitoring of subject software will not be supported by releasing
	Government Agency] In an effort to track usage and maintain accurate
	records of the Subject Software, each Recipient, upon receipt of the
	Subject Software, is requested to provide Government Agency, by e-mail
	to the Government Agency Point of Contact listed in clause 5.F., the
	following information: ______________________________.  Recipient's
	name and personal information shall be used for statistical purposes
	only. Once a Recipient makes a Modification available, it is requested
	that the Recipient inform Government Agency, by e-mail to the
	Government Agency Point of Contact listed in clause 5.F., how to
	access the Modification.

	G. Each Contributor represents that that its Modification is believed
	to be Contributor's original creation and does not violate any
	existing agreements, regulations, statutes or rules, and further that
	Contributor has sufficient rights to grant the rights conveyed by this
	Agreement.

	H. A Recipient may choose to offer, and to charge a fee for, warranty,
	support, indemnity and/or liability obligations to one or more other
	Recipients of the Subject Software.  A Recipient may do so, however,
	only on its own behalf and not on behalf of Government Agency or any
	other Recipient.  Such a Recipient must make it absolutely clear that
	any such warranty, support, indemnity and/or liability obligation is
	offered by that Recipient alone.  Further, such Recipient agrees to
	indemnify Government Agency and every other Recipient for any
	liability incurred by them as a result of warranty, support, indemnity
	and/or liability offered by such Recipient.

	I. A Recipient may create a Larger Work by combining Subject Software
	with separate software not governed by the terms of this agreement and
	distribute the Larger Work as a single product. In such case, the
	Recipient must make sure Subject Software, or portions thereof,
	included in the Larger Work is subject to this Agreement.

	J. Notwithstanding any provisions contained herein, Recipient is
	hereby put on notice that export of any goods or technical data from
	the United States may require some form of export license from the
	U.S. Government.  Failure to obtain necessary export licenses may
	result in criminal liability under U.S. laws.  Government Agency
	neither represents that a license shall not be required nor that, if
	required, it shall be issued.  Nothing granted herein provides any
	such export license.

	4. DISCLAIMER OF WARRANTIES AND LIABILITIES; WAIVER AND INDEMNIFICATION

	A. No Warranty: THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY
	WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY,
	INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE
	WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR FREEDOM FROM
	INFRINGEMENT, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL BE ERROR
	FREE, OR ANY WARRANTY THAT DOCUMENTATION, IF PROVIDED, WILL CONFORM TO
	THE SUBJECT SOFTWARE. THIS AGREEMENT DOES NOT, IN ANY MANNER,
	CONSTITUTE AN ENDORSEMENT BY GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT
	OF ANY RESULTS, RESULTING DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY
	OTHER APPLICATIONS RESULTING FROM USE OF THE SUBJECT SOFTWARE.
	FURTHER, GOVERNMENT AGENCY DISCLAIMS ALL WARRANTIES AND LIABILITIES
	REGARDING THIRD-PARTY SOFTWARE, IF PRESENT IN THE ORIGINAL SOFTWARE,
	AND DISTRIBUTES IT "AS IS."

	B. Waiver and Indemnity: RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS
	AGAINST THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
	SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT.  IF RECIPIENT'S USE OF
	THE SUBJECT SOFTWARE RESULTS IN ANY LIABILITIES, DEMANDS, DAMAGES,
	EXPENSES OR LOSSES ARISING FROM SUCH USE, INCLUDING ANY DAMAGES FROM
	PRODUCTS BASED ON, OR RESULTING FROM, RECIPIENT'S USE OF THE SUBJECT
	SOFTWARE, RECIPIENT SHALL INDEMNIFY AND HOLD HARMLESS THE UNITED
	STATES GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY
	PRIOR RECIPIENT, TO THE EXTENT PERMITTED BY LAW.  RECIPIENT'S SOLE
	REMEDY FOR ANY SUCH MATTER SHALL BE THE IMMEDIATE, UNILATERAL
	TERMINATION OF THIS AGREEMENT.


	5. GENERAL TERMS

	A. Termination: This Agreement and the rights granted hereunder will
	terminate automatically if a Recipient fails to comply with these
	terms and conditions, and fails to cure such noncompliance within
	thirty (30) days of becoming aware of such noncompliance.  Upon
	termination, a Recipient agrees to immediately cease use and
	distribution of the Subject Software.  All sublicenses to the Subject
	Software properly granted by the breaching Recipient shall survive any
	such termination of this Agreement.

	B. Severability: If any provision of this Agreement is invalid or
	unenforceable under applicable law, it shall not affect the validity
	or enforceability of the remainder of the terms of this Agreement.

	C. Applicable Law: This Agreement shall be subject to United States
	federal law only for all purposes, including, but not limited to,
	determining the validity of this Agreement, the meaning of its
	provisions and the rights, obligations and remedies of the parties.

	D. Entire Understanding: This Agreement constitutes the entire
	understanding and agreement of the parties relating to release of the
	Subject Software and may not be superseded, modified or amended except
	by further written agreement duly executed by the parties.

	E. Binding Authority: By accepting and using the Subject Software
	under this Agreement, a Recipient affirms its authority to bind the
	Recipient to all terms and conditions of this Agreement and that that
	Recipient hereby agrees to all terms and conditions herein.

	F. Point of Contact: Any Recipient contact with Government Agency is
	to be directed to the designated representative as follows:
	___________________________________________________________.
 *
 *
 *
 */
#endregion

using Microsoft.DirectX.Direct3D;
using Microsoft.DirectX;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Net;
using System.Security.Permissions;
using System.Threading;
using System.Windows.Forms;
using System;
using WorldWind.Camera;
using WorldWind.Menu;
using WorldWind;
using WorldWind.Net;
using WorldWind.Net.Wms;
using WorldWind.Interop;
using WorldWind.VisualControl;
using Utility;

namespace WorldWind
{
	public class WorldWindow : Control, IGlobe
	{
		/// <summary>
		/// Direct3D rendering m_Device3d
		/// </summary>
		private Device m_Device3d;
		private PresentParameters m_presentParams;
		private DrawArgs drawArgs;
		private World m_World;
		private Cache m_Cache;
		private Thread m_WorkerThread;
		private bool showDiagnosticInfo;
		private string _caption = "";
		private long lastFpsUpdateTime;
		private int frameCounter;
		private float fps;
		private string saveScreenShotFilePath;
		private ImageFileFormat saveScreenShotImageFileFormat = ImageFileFormat.Bmp;
		private bool m_WorkerThreadRunning;
		private LayerManagerButton layerManagerButton;
		private MenuBar _menuBar = new MenuBar(MenuAnchor.Top, 90);
		private bool m_isRenderDisabled; // True when WW isn't active - CPU saver
		private bool isMouseDragging;
		private Point mouseDownStartPosition = Point.Empty;
		private bool renderWireFrame;
		private System.Timers.Timer m_FpsTimer = new System.Timers.Timer(250);

//		protected DownloadIndicator m_downloadIndicator;

		/// <summary>
		/// Initializes a new instance of the <see cref= "T:WorldWind.WorldWindow"/> class.
		/// </summary>
		public WorldWindow()
		{
			this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.Opaque, true);

			// The m_Device3d can't be created unless the control is at least 1 x 1 pixels in size
			this.Size = new Size(1,1);

			try
			{
				// Now perform the rendering m_Device3d initialization
				// Skip DirectX initialization in design mode
				if(!IsInDesignMode())
					this.InitializeGraphics();

				//Post m_Device3d creation initialization
				this.drawArgs = new DrawArgs(m_Device3d, this );
				this.m_RootWidget = new WorldWind.Widgets.RootWidget(this);
                this.m_NewRootWidget = new WorldWind.NewWidgets.RootWidget(this);

				//this.m_RootWidget.ChildWidgets.Add(layerManager);
				DrawArgs.RootWidget = this.m_RootWidget;
                DrawArgs.NewRootWidget = this.m_NewRootWidget;

				m_FpsTimer.Elapsed += new System.Timers.ElapsedEventHandler(m_FpsTimer_Elapsed);
				m_FpsTimer.Start();

				TimeKeeper.Start();
			//	WorldWind.Widgets.LayerManager layerManager = new WorldWind.Widgets.LayerManager();
			//	m_RootWidget.ChildWidgets.Add(layerManager);

			}
			catch (InvalidCallException caught)
			{
				throw new InvalidCallException(
					"Unable to locate a compatible graphics adapter. Make sure you are running the latest version of DirectX.", caught );
			}
			catch (NotAvailableException caught)
			{
				throw new NotAvailableException(
					"Unable to locate a compatible graphics adapter. Make sure you are running the latest version of DirectX.", caught );
			}
		}

		//Widgets.LayerManager layerManager = new WorldWind.Widgets.LayerManager();

		#region Public properties

		public World CurrentWorld
		{
			get
			{
				return m_World;
			}
			set
			{
				m_World = value;
				if(m_World != null)
				{
					MomentumCamera camera = new MomentumCamera(m_World.Position, m_World.EquatorialRadius );
					if(!World.Settings.CameraResetsAtStartup)
					{
						camera.SetPosition(
							World.Settings.CameraLatitude.Degrees,
							World.Settings.CameraLongitude.Degrees,
							World.Settings.CameraHeading.Degrees, 
							World.Settings.CameraAltitude,
							World.Settings.CameraTilt.Degrees,
							0
							);
					}
					this.drawArgs.WorldCamera = camera;
					
					this.drawArgs.CurrentWorld = value;
					this.layerManagerButton = new LayerManagerButton(
						Path.Combine(Path.GetDirectoryName(Application.ExecutablePath), @"Data\Icons\Interface\layer-manager2.png"),
						m_World);
					
					this._menuBar.AddToolsMenuButton( this.layerManagerButton, 0 );
					this._menuBar.AddToolsMenuButton( new PositionMenuButton( Path.GetDirectoryName(Application.ExecutablePath) + "\\Data\\Icons\\Interface\\coordinates.png"), 1);
					this._menuBar.AddToolsMenuButton( new LatLonMenuButton( Path.GetDirectoryName(Application.ExecutablePath) + "\\Data\\Icons\\Interface\\lat-long.png", m_World), 2);
					this.layerManagerButton.SetPushed(World.Settings.ShowLayerManager);
					
					// TODO: Decide how to load grids
					m_World.RenderableObjects.Add(new Renderable.LatLongGrid(m_World));
				}
			}
		}

		public string Caption
		{
			get
			{
				return this._caption;
			}
			set
			{
				this._caption = value;
			}
		}

		public DrawArgs DrawArgs
		{
			get { return this.drawArgs; }
		}


		public MenuBar MenuBar
		{
			get
			{
				return this._menuBar;
			}
		}

		public bool ShowLayerManager
		{
			get
			{
				if(this.layerManagerButton != null)
					return this.layerManagerButton.IsPushed();
				else
					return false;
			}
			set
			{
				if(this.layerManagerButton != null)
					this.layerManagerButton.SetPushed(value);
			}
		}

		public Cache Cache
		{
			get
			{
				return m_Cache;
			}
			set
			{
				m_Cache = value;
			}
		}

		/// <summary>
		/// Disables rendering (CPU tick saver)
		/// </summary>
		public bool IsRenderDisabled
		{
			get
			{
				return m_isRenderDisabled;
			}
			set
			{
				m_isRenderDisabled = value;
			}
		}

		#endregion

		#region Public methods

		/// <summary>
		/// Go to worldwind URI
		/// </summary>
		public void Goto( WorldWind.Net.WorldWindUri uri )
		{
			GotoLatLon(
				uri.Latitude.Degrees, uri.Longitude.Degrees, uri.Direction.Degrees, 
				uri.Altitude, uri.ViewRange.Degrees, uri.Tilt.Degrees);
			drawArgs.WorldCamera.Bank = uri.Bank;
			drawArgs.UpperLeftCornerText = uri.ToString();
			CurrentWorld.RenderableObjects.Enable( uri.Layer );
		}

		/// <summary>
		/// Moves to specified location.
		/// </summary>
		/// <param name="latitude">Latitude in degrees of target position. (-90 - 90).</param>
		/// <param name="longitude">Longitude in degrees of target position. (-180 - 180).</param>
		/// <param name="heading">Camera heading in degrees (0-360) or double.NaN for no change.</param>
		/// <param name="altitude">Camera altitude in meters or double.NaN for no change.</param>
		/// <param name="perpendicularViewRange"></param>
		/// <param name="tilt">Camera tilt in degrees (-90 - 90) or double.NaN for no change.</param>
		public void GotoLatLon(double latitude, double longitude, double heading, double altitude, double perpendicularViewRange, double tilt)
		{
			if(!double.IsNaN(perpendicularViewRange))
				altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
			if (altitude<1)
				altitude = 1;
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude, heading, altitude, tilt);
		}

		public void GotoLatLon(double latitude, double longitude)
		{
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
				this.drawArgs.WorldCamera.Heading.Degrees,
				this.drawArgs.WorldCamera.Altitude,
				this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		public void GotoLatLonAltitude(double latitude, double longitude, double altitude)
		{
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
				this.drawArgs.WorldCamera.Heading.Degrees,
				altitude,
				this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		public void GotoLatLonHeadingViewRange(double latitude, double longitude, double heading, double perpendicularViewRange)
		{
			double altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
			this.GotoLatLonHeadingAltitude(latitude, longitude, heading, altitude);
		}

		public void GotoLatLonViewRange(double latitude, double longitude, double perpendicularViewRange)
		{
			double altitude = m_World.EquatorialRadius * Math.Sin(MathEngine.DegreesToRadians(perpendicularViewRange * 0.5));
			this.GotoLatLonHeadingAltitude(latitude, longitude, this.drawArgs.WorldCamera.Heading.Degrees, altitude);
		}

		public void GotoLatLonHeadingAltitude(double latitude, double longitude, double heading, double altitude)
		{
			this.drawArgs.WorldCamera.SetPosition(latitude, longitude,
				heading,
				altitude,
				this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		/// <summary>
		/// Saves the current view to file.
		/// </summary>
		/// <param name="filePath">Path and filename of output file.  
		/// Extension is used to determine the image format.</param>
		public void SaveScreenshot(string filePath)
		{
			if(m_Device3d == null)
				return;

			FileInfo saveFileInfo = new FileInfo(filePath);
			string ext = saveFileInfo.Extension.Replace(".","");
			try
			{
				this.saveScreenShotImageFileFormat = (ImageFileFormat) Enum.Parse(typeof(ImageFileFormat), ext, true );
			}
			catch(ArgumentException)
			{
				throw new ApplicationException("Unknown file type/file extension for file '"+filePath+"'.  Unable to save.");
			}

			if(!saveFileInfo.Directory.Exists)
				saveFileInfo.Directory.Create();

			this.saveScreenShotFilePath = filePath;
		}

		/// <summary>
		/// The world render loop.  
		/// Borrowed from FlightGear and Tom Miller's blog
		/// </summary>
		public void OnApplicationIdle(object sender, EventArgs e)
		{
			// Sleep will always overshoot by a bit so under-sleep by
			// 2ms in the hopes of never oversleeping.
			const float SleepOverHeadSeconds = 2e-3f;

			// Overhead associated with displaying the frame
			const float PresentOverheadSeconds = 0;//3e-4f;

			try
			{
                if (Parent.Focused && !Focused)
                    Focus();

				while (IsAppStillIdle)
				{
					if (!World.Settings.AlwaysRenderWindow && m_isRenderDisabled && !World.Settings.CameraHasMomentum)
						return;

					Render();

					if (World.Settings.ThrottleFpsHz > 0)
					{
						// optionally throttle the frame rate (to get consistent frame
						// rates or reduce CPU usage.
						float frameSeconds = 1.0f / World.Settings.ThrottleFpsHz - PresentOverheadSeconds;

						// Sleep for remaining period of time until next render
						float sleepSeconds = frameSeconds - SleepOverHeadSeconds - DrawArgs.SecondsSinceLastFrame;
						if(sleepSeconds > 0)
						{
							// Don't sleep too long. We don't know the accuracy of Thread.Sleep
							Thread.Sleep((int) (1000 * sleepSeconds)); 

							// Burn off what little time still remains at 100% CPU load
							while(DrawArgs.SecondsSinceLastFrame < frameSeconds)
							{
								// Patience
							}
						}
					}
					// Flip
					drawArgs.Present();
				}
			}
			catch(DeviceLostException)
			{
				AttemptRecovery();
			}
			catch(Exception caught)
			{
				Log.Write(caught);
			}
		}

		#endregion

		/// <summary>
		/// Determine whether any window messages is queued.
		/// </summary>
		private static bool IsAppStillIdle
		{
			get
			{
				NativeMethods.Message msg;
				return !NativeMethods.PeekMessage(out msg, IntPtr.Zero, 0, 0, 0);
			}
		}		
		
		/// <summary>
		/// Occurs when the control is redrawn and m_isRenderDisabled=true.
		/// All other painting is handled in WndProc.
		/// </summary>
		/// <param name="e"></param>
		protected override void OnPaint(PaintEventArgs e)
		{
			// Paint the last active scene if rendering is disabled to keep the ui responsive
			try
			{
				if(m_Device3d==null)
				{
					e.Graphics.Clear(SystemColors.Control);
					return;
				}

                // to prevent screen garbage when resizing
                Render();
				m_Device3d.Present();
			}
			catch(DeviceLostException)
			{
				try
				{
					AttemptRecovery();

					// Our surface was lost, force re-render
					Render();

					m_Device3d.Present();
				}
				catch(DirectXException)
				{
					// Ignore a 2nd failure
				}
			}
		}

		System.Collections.ArrayList m_FrameTimes = new ArrayList();
		WorldWind.Widgets.RootWidget m_RootWidget = null;
        WorldWind.NewWidgets.RootWidget m_NewRootWidget = null;
		/// <summary>
		/// Render the scene.
		/// </summary>
		public void Render()
		{
			long startTicks = 0;
			PerformanceTimer.QueryPerformanceCounter(ref startTicks);

            try
            {
                this.drawArgs.BeginRender();

                // Render the sky according to view - example, close to earth, render sky blue, render space as black
                System.Drawing.Color backgroundColor = System.Drawing.Color.Black;

                /*if(drawArgs.WorldCamera != null && 
                    drawArgs.WorldCamera.Altitude < 1000000f &&
                    m_World != null &&
                    m_World.Name.IndexOf("Earth") >= 0)
                {
                    float percent = 1 - (float)(drawArgs.WorldCamera.Altitude / 1000000);
                    if(percent > 1.0f)
                        percent = 1.0f;
                    else if(percent < 0.0f)
                        percent = 0.0f;

                    backgroundColor = System.Drawing.Color.FromArgb(
                        (int)(World.Settings.SkyColor.R*percent),
                        (int)(World.Settings.SkyColor.G*percent),
                        (int)(World.Settings.SkyColor.B*percent));
                }*/

                m_Device3d.Clear(ClearFlags.Target | ClearFlags.ZBuffer, backgroundColor, 1.0f, 0);

                if (m_World == null)
                {
                    m_Device3d.BeginScene();
                    m_Device3d.EndScene();
                    m_Device3d.Present();
                    Thread.Sleep(25);
                    return;
                }

                if (m_WorkerThread == null)
                {
                    m_WorkerThreadRunning = true;
                    m_WorkerThread = new Thread(new ThreadStart(WorkerThreadFunc));
                    m_WorkerThread.Name = "WorldWindow.WorkerThreadFunc";
                    m_WorkerThread.IsBackground = true;
                    if (World.Settings.UseBelowNormalPriorityUpdateThread)
                    {
                        m_WorkerThread.Priority = ThreadPriority.BelowNormal;
                    }
                    else
                    {
                        m_WorkerThread.Priority = ThreadPriority.Normal;
                    }
                    // BelowNormal makes rendering smooth, but on slower machines updates become slow or stops
                    // TODO: Implement dynamic FPS limiter (or different solution)
                    m_WorkerThread.Start();
                }

                this.drawArgs.WorldCamera.Update(m_Device3d);

                m_Device3d.BeginScene();

                // Set fill mode
                if (renderWireFrame)
                    m_Device3d.RenderState.FillMode = FillMode.WireFrame;
                else
                    m_Device3d.RenderState.FillMode = FillMode.Solid;

                drawArgs.RenderWireFrame = renderWireFrame;

                // Render the current planet
                m_World.Render(this.drawArgs);

                if (World.Settings.ShowCrosshairs)
                    this.DrawCrossHairs();

                frameCounter++;
                if (frameCounter == 30)
                {
                    fps = frameCounter / (float)(DrawArgs.CurrentFrameStartTicks - lastFpsUpdateTime) * PerformanceTimer.TicksPerSecond;
                    frameCounter = 0;
                    lastFpsUpdateTime = DrawArgs.CurrentFrameStartTicks;
                }

                m_RootWidget.Render(drawArgs);
                m_NewRootWidget.Render(drawArgs);

                if (saveScreenShotFilePath != null)
                    SaveScreenShot();

                drawArgs.device.RenderState.ZBufferEnable = false;

                // 3D rendering complete, switch to 2D for UI rendering

                // Restore normal fill mode
                if (renderWireFrame)
                    m_Device3d.RenderState.FillMode = FillMode.Solid;

                // Disable fog for UI
                m_Device3d.RenderState.FogEnable = false;

                /*
                                if(World.Settings.ShowDownloadIndicator)
                                {
                                    if(m_downloadIndicator == null)
                                        m_downloadIndicator = new DownloadIndicator();
                                    m_downloadIndicator.Render(drawArgs);
                                }
                */
                RenderPositionInfo();

                _menuBar.Render(drawArgs);
                m_FpsGraph.Render(drawArgs);
                
                if (m_World.OnScreenMessages != null)
                {
                    try
                    {
                        foreach (OnScreenMessage dm in m_World.OnScreenMessages)
                        {
                            int xPos = (int)Math.Round(dm.X * this.Width);
                            int yPos = (int)Math.Round(dm.Y * this.Height);
                            Rectangle posRect =
                                new Rectangle(xPos, yPos, this.Width, this.Height);
                            this.drawArgs.defaultDrawingFont.DrawText(null,
                                dm.Message, posRect,
                                DrawTextFormat.NoClip | DrawTextFormat.WordBreak,
                                Color.White);
                        }
                    }
                    catch (Exception)
                    {
                        // Don't let a script error cancel the frame.
                    }
                }

                m_Device3d.EndScene();
            }
            catch (Exception ex)
            {
                Log.Write(ex);
            }
			finally
			{
				
				if(World.Settings.ShowFpsGraph)
				{
					long endTicks = 0;
					PerformanceTimer.QueryPerformanceCounter(ref endTicks);
					float elapsedMilliSeconds = 1000.0f / (1000.0f*(float)(endTicks - startTicks)/PerformanceTimer.TicksPerSecond);
					m_FrameTimes.Add(elapsedMilliSeconds);
				}
				this.drawArgs.EndRender();
			}
			drawArgs.UpdateMouseCursor(this);
		}

		private LineGraph m_FpsGraph = new LineGraph();

		public void ResetToolbar()
		{
			lock(this._menuBar.LayersMenuButtons.SyncRoot)
			{
				foreach(IMenu m in this._menuBar.LayersMenuButtons)
				{
					m.Dispose();
				}
				this._menuBar.LayersMenuButtons.Clear();
			}

			lock(this._menuBar.ToolsMenuButtons.SyncRoot)
			{

					for(int i = 0; i < this._menuBar.ToolsMenuButtons.Count; i++)
					{
						IMenu m = (IMenu)this._menuBar.ToolsMenuButtons[i];
						if(m != null)
						{
							m.Dispose();
						}
					}

					this._menuBar.ToolsMenuButtons.Clear();
			}
		}

		private const int positionAlphaStep = 20;
		private int positionAlpha = 255;
		private int positionAlphaMin = 40;
		private int positionAlphaMax = 205;

		protected void RenderPositionInfo()
		{
			// Render some Development information to screen
			string captionText = _caption;

			captionText += "\n" + this.drawArgs.UpperLeftCornerText;

			if(World.Settings.ShowPosition)
			{
				string alt = null;
				double agl = this.drawArgs.WorldCamera.AltitudeAboveTerrain;
				/*if(agl>100000)
					alt = string.Format("{0:f2}km", agl/1000);
				else
					alt = string.Format("{0:f0}m", agl);*/
				alt = ConvertUnits.GetDisplayString(agl);

				string dist = null;
				double dgl = this.drawArgs.WorldCamera.Distance;
				/*if(dgl>100000)
					dist = string.Format("{0:f2}km", dgl/1000);
				else
					dist = string.Format("{0:f0}m", dgl);*/
				dist = ConvertUnits.GetDisplayString(dgl);
				
				// Heading from 0 - 360
				double heading = this.drawArgs.WorldCamera.Heading.Degrees;
				if(heading<0)
					heading+=360;
				captionText += String.Format("Latitude: {0}\nLongitude: {1}\nHeading: {2:f2}Ӱ\nTilt: {3}\nAltitude: {4}\nDistance: {5}\nFOV: {6}",
					this.drawArgs.WorldCamera.Latitude,
					this.drawArgs.WorldCamera.Longitude,
					heading,
					this.drawArgs.WorldCamera.Tilt,
					alt,
					dist,
					this.drawArgs.WorldCamera.Fov );

				if(agl < 300000)
				{
					captionText += String.Format("\nTerrain Elevation: {0:n} meters\n", this.drawArgs.WorldCamera.TerrainElevation);
				}
			}

			if(this.showDiagnosticInfo)
				captionText +=
					"\nAvailable Texture Memory: " + (m_Device3d.AvailableTextureMemory/1024).ToString("N0") + " kB"+
					"\nBoundary Points: " + this.drawArgs.numBoundaryPointsRendered.ToString() + " / " + this.drawArgs.numBoundaryPointsTotal.ToString() + " : " + this.drawArgs.numBoundariesDrawn.ToString() +
					"\nTiles Drawn: " + (this.drawArgs.numberTilesDrawn * 0.25f).ToString() +
					"\n" + this.drawArgs.WorldCamera +
					"\nFPS: " + this.fps.ToString("f1") +
					"\nRO: " + m_World.RenderableObjects.Count.ToString("f0") +
					"\nmLat: " + this.cLat.Degrees.ToString() + 
					"\nmLon: " + this.cLon.Degrees.ToString() + 
					"\n" + TimeKeeper.CurrentTimeUtc.ToLocalTime().ToLongTimeString();


			captionText = captionText.Trim();
			DrawTextFormat dtf = DrawTextFormat.NoClip | DrawTextFormat.WordBreak | DrawTextFormat.Right;
			int x = 7;
			int y = _menuBar!=null && World.Settings.ShowToolbar ? 65 : 7;
			Rectangle textRect = Rectangle.FromLTRB(x,y, this.Width-8, this.Height-8 );

			// Hide position info when toolbar is open
			if (_menuBar.IsActive)
			{
				positionAlpha -= positionAlphaStep;
				if (positionAlpha<positionAlphaMin)
				{
					positionAlpha=positionAlphaMin;
				}
			}
			else
			{
				positionAlpha += positionAlphaStep;
				if(positionAlpha>positionAlphaMax)
					positionAlpha = positionAlphaMax;
			}

			int positionBackColor = positionAlpha << 24;
			int positionForeColor = (int)((uint)(positionAlpha << 24) + 0xffffffu);
			this.drawArgs.defaultDrawingFont.DrawText( null, captionText, textRect, dtf, positionBackColor);
			textRect.Offset(-1,-1);
			this.drawArgs.defaultDrawingFont.DrawText( null, captionText, textRect, dtf, positionForeColor);
		}


		/// <summary>
		/// Draws a small cross hairs for the user to pinpoint the exact lat/lon
		/// TODO: Make this user-resizeable and color customizable
		/// </summary>
		Line crossHairs;
		int crossHairColor = Color.GhostWhite.ToArgb();
		protected void DrawCrossHairs()
		{
			int crossHairSize = 10;

			if(this.crossHairs == null)
			{
				crossHairs = new Line(m_Device3d);
			}

			Vector2[] vertical = new Vector2[2];
			Vector2[] horizontal = new Vector2[2];

			horizontal[0].X = this.Width / 2 - crossHairSize;
			horizontal[0].Y = this.Height / 2;
			horizontal[1].X = this.Width / 2 + crossHairSize;
			horizontal[1].Y = this.Height / 2;

			vertical[0].X = this.Width / 2;
			vertical[0].Y = this.Height / 2 - crossHairSize;
			vertical[1].X = this.Width / 2;
			vertical[1].Y = this.Height / 2 + crossHairSize;

			crossHairs.Begin();
			crossHairs.Draw(horizontal, crossHairColor);
			crossHairs.Draw(vertical, crossHairColor);
			crossHairs.End();
		}

		/// <summary>
		/// Attempt to restore the 3D m_Device3d
		/// </summary>
		protected void AttemptRecovery()
		{
			try
			{
				m_Device3d.TestCooperativeLevel();
			}
			catch (DeviceLostException)
			{
			}
			catch (DeviceNotResetException)
			{
				try
				{
					m_Device3d.Reset(m_presentParams);
				}
				catch (DeviceLostException)
				{
					// If it's still lost or lost again, just do
					// nothing
				}
			}
		}

		#region Event handlers

        public void HandleMouseWheel(MouseEventArgs e)
        {
            OnMouseWheel(e);
        }

		/// <summary>
		/// Occurs when the mouse wheel moves while the control has focus.
		/// </summary>
		protected override void OnMouseWheel(MouseEventArgs e)
        {
            try
			{
				if(this._menuBar.OnMouseWheel(e))
					return;

				this.drawArgs.WorldCamera.ZoomStepped( e.Delta/120.0f );
			}
			finally
			{
                if (m_NewRootWidget != null)
                {
                    try
                    {
                        m_NewRootWidget.OnMouseWheel(e);
                    }
                    finally
                    {
                    }
                }

				// Call the base class's OnMouseWheel method so that registered delegates receive the event.
				base.OnMouseWheel(e);
			}
		}

		/// <summary>
		/// Occurs when a key is pressed while the control has focus.
		/// </summary>
		protected override void OnKeyDown(KeyEventArgs e)
		{
			try
			{
				e.Handled = HandleKeyDown(e);
				base.OnKeyDown(e);
			}
			catch (Exception caught)
			{
				MessageBox.Show( caught.Message, "Operation failed", MessageBoxButtons.OK, MessageBoxIcon.Error );
			}
		}

		/// <summary>
		/// Occurs when a key is released while the control has focus.
		/// </summary>
		protected override void OnKeyUp(KeyEventArgs e)
		{
			try
			{
				e.Handled = HandleKeyUp(e);
				base.OnKeyUp(e);
			}
			catch (Exception caught)
			{
				MessageBox.Show( caught.Message, "Operation failed", MessageBoxButtons.OK, MessageBoxIcon.Error );
			}
		}

		protected override void OnKeyPress(KeyPressEventArgs e)
		{
            if (m_RootWidget != null)
            {
                bool handled = m_RootWidget.OnKeyPress(e);
                e.Handled = handled;
            }
            if (m_NewRootWidget != null)
            {
                bool handled = m_NewRootWidget.OnKeyPress(e);
                e.Handled = handled;
            }
            base.OnKeyPress(e);
		}


		/// <summary>
		/// Preprocess keyboard or input messages within the message loop before they are dispatched.
		/// </summary>
		/// <param name="msg">A Message, passed by reference, that represents the message to process. 
		/// The possible values are WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR, and WM_SYSCHAR.</param>
		[SecurityPermission(SecurityAction.LinkDemand, UnmanagedCode=true), SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=true)]
		public override bool PreProcessMessage(ref Message msg)
		{
			const int WM_KEYDOWN = 0x0100;

			// it's the only way to handle arrow keys in OnKeyDown
			if (msg.Msg == WM_KEYDOWN)
			{
				Keys key = (Keys)msg.WParam.ToInt32();
				switch (key)
				{
					case Keys.Left:
					case Keys.Up:
					case Keys.Right:
					case Keys.Down:
						OnKeyDown(new KeyEventArgs(key));
						// mark message as processed
						msg.Result = (IntPtr) 1;
						// When overriding PreProcessMessage, a control should return true to indicate that it has processed the message.
						return true;
				}
			}

			return base.PreProcessMessage (ref msg);
		}


		/// <summary>
		/// Handles key down events.
		/// </summary>
		/// <param name="e"></param>
		/// <returns>Returns true if the key is handled.</returns>
		public bool HandleKeyDown(KeyEventArgs e)
		{

			bool handled = this.m_RootWidget.OnKeyDown(e);
			if(handled)
				return handled;

            handled = this.m_NewRootWidget.OnKeyDown(e);
            if (handled)
                return handled;

			// Alt key down
			if (e.Alt)
			{
				switch (e.KeyCode)
				{
					case Keys.C:
						World.Settings.ShowCrosshairs = !World.Settings.ShowCrosshairs;
						return true;
					case Keys.Add:
					case Keys.Oemplus:
					case Keys.Home:
					case Keys.NumPad7:
						this.drawArgs.WorldCamera.Fov -= Angle.FromDegrees( 5 );
						return true;
					case Keys.Subtract:
					case Keys.OemMinus:
					case Keys.End:
					case Keys.NumPad1:
						this.drawArgs.WorldCamera.Fov += Angle.FromDegrees( 5 );
						return true;
				}
			}
				// Control key down
			else if (e.Control)
			{
			}
				// Other and no control key
			else
			{
				switch (e.KeyCode)
				{
					// rotate left
					case Keys.A:
						if (!e.Shift)
						{
							Angle rotateClockwise = Angle.FromRadians(0.01f);
							this.drawArgs.WorldCamera.Heading += rotateClockwise;
							this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateClockwise);
						}
						return true;
					// rotate right
					case Keys.D:
						Angle rotateCounterclockwise = Angle.FromRadians(-0.01f);
						this.drawArgs.WorldCamera.Heading += rotateCounterclockwise;
						this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, Angle.Zero, rotateCounterclockwise);
						return true;
					// rotate up
					case Keys.W:
						this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees( -1.0f );
						return true;
					// rotate down
					case Keys.S:
						if (!e.Shift)
						{
							this.drawArgs.WorldCamera.Tilt += Angle.FromDegrees(1.0f);
						}
						return true;
					// pan left
					case Keys.Left:
					case Keys.H:
					case Keys.NumPad4:
						// TODO: pan n pixels
						Angle panLeft = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
						this.drawArgs.WorldCamera.RotationYawPitchRoll( panLeft, Angle.Zero, Angle.Zero);
						return true;
					// pan down
					case Keys.Down:
					case Keys.J:
					case Keys.NumPad2:
						Angle panDown = Angle.FromRadians((float)-1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
						this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panDown, Angle.Zero);
						return true;
					// pan right
					case Keys.Right:
					case Keys.K:
					case Keys.NumPad6:
						Angle panRight = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
						this.drawArgs.WorldCamera.RotationYawPitchRoll(panRight, Angle.Zero, Angle.Zero);
						return true;
					// pan up
					case Keys.Up:
					case Keys.U:
					case Keys.NumPad8:
						// TODO: Pan n pixels
						Angle panUp = Angle.FromRadians((float)1 * (this.drawArgs.WorldCamera.Altitude) * (1 / (300 * this.CurrentWorld.EquatorialRadius)));
						this.drawArgs.WorldCamera.RotationYawPitchRoll(Angle.Zero, panUp, Angle.Zero);
						return true;
					// zoom in
					case Keys.Add:
					case Keys.Oemplus:
					case Keys.Home:
					case Keys.NumPad7:
						this.drawArgs.WorldCamera.ZoomStepped( World.Settings.CameraZoomStepKeyboard);
						return true;
					// zoom out
					case Keys.Subtract:
					case Keys.OemMinus:
					case Keys.End:
					case Keys.NumPad1:
						this.drawArgs.WorldCamera.ZoomStepped( -World.Settings.CameraZoomStepKeyboard );
						return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Handles key up events.
		/// </summary>
		/// <param name="e"></param>
		/// <returns>Returns true if the key is handled.</returns>
		public bool HandleKeyUp(KeyEventArgs e)
		{

			bool handled = m_RootWidget.OnKeyUp(e);
			if(handled)
			{
				e.Handled = handled;
				return handled;
			}
            handled = m_NewRootWidget.OnKeyUp(e);
            if (handled)
            {
                e.Handled = handled;
                return handled;
            }

			// Alt key down
			if (e.Alt)
			{
			}
			// Control key down
			else if (e.Control)
			{
				switch (e.KeyCode)
				{
					case Keys.D:
						this.showDiagnosticInfo = !this.showDiagnosticInfo;
						return true;
					case Keys.W:
						renderWireFrame = !renderWireFrame;
						return true;
				}
			}
				// Other and no control key
			else
			{
				switch (e.KeyCode)
				{
					case Keys.Space:
					case Keys.Clear:
						this.drawArgs.WorldCamera.Reset();
						return true;
				}
			}
			return false;
		}

		protected override void OnMouseDown(MouseEventArgs e)
		{
			this.Focus();  //fixes mousewheel not working problem

			DrawArgs.LastMousePosition.X = e.X;
			DrawArgs.LastMousePosition.Y = e.Y;

			mouseDownStartPosition.X = e.X;
			mouseDownStartPosition.Y = e.Y;


			try
			{
				bool handled = false;
				handled = m_RootWidget.OnMouseDown(e);

                if (!handled)
                {
                    handled = m_NewRootWidget.OnMouseDown(e);
                }

				if(!handled)
				{
					if(!this._menuBar.OnMouseDown(e))
					{

					}
				}
			}
			finally
			{
				if(e.Button == MouseButtons.Left)
					DrawArgs.IsLeftMouseButtonDown = true;

				if(e.Button == MouseButtons.Right)
					DrawArgs.IsRightMouseButtonDown = true;
				// Call the base class method so that registered delegates receive the event.
				base.OnMouseDown(e);
			}
		}

        bool isDoubleClick = false;
        protected override void OnMouseDoubleClick(MouseEventArgs e)
        {
            isDoubleClick = true;
            base.OnMouseDoubleClick(e);
        }

		protected override void OnMouseUp(MouseEventArgs e)
        {
            DrawArgs.LastMousePosition.X = e.X;
			DrawArgs.LastMousePosition.Y = e.Y;

			try
			{
                bool handled = false;

				handled = m_RootWidget.OnMouseUp(e);

                if (!handled)
                {
                    handled = m_NewRootWidget.OnMouseUp(e);
                }

				if(!handled)
				{
					// Mouse must have been clicked outside our window and released on us, ignore
					if(mouseDownStartPosition==Point.Empty)
						return;

					mouseDownStartPosition = Point.Empty;

					if(!this.isMouseDragging)
					{
						if(this._menuBar.OnMouseUp(e))
							return;
					}

					if(m_World == null)
						return;

                    if (isDoubleClick)
                    {
                        isDoubleClick = false;
                        if (e.Button == MouseButtons.Left)
                        {
                            drawArgs.WorldCamera.Zoom(World.Settings.CameraDoubleClickZoomFactor);
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            drawArgs.WorldCamera.Zoom(-World.Settings.CameraDoubleClickZoomFactor);
                        }
                    }
                    else
                    {
                        if (e.Button == MouseButtons.Left)
                        {
                            if (this.isMouseDragging)
                            {
                                this.isMouseDragging = false;
                            }
                            else
                            {
                                if (!m_World.PerformSelectionAction(this.drawArgs))
                                {

                                    Angle targetLatitude;
                                    Angle targetLongitude;
                                    //Quaternion targetOrientation = new Quaternion();
                                    this.drawArgs.WorldCamera.PickingRayIntersection(
                                        DrawArgs.LastMousePosition.X,
                                        DrawArgs.LastMousePosition.Y,
                                        out targetLatitude,
                                        out targetLongitude);
                                    if (!Angle.IsNaN(targetLatitude))
                                        this.drawArgs.WorldCamera.PointGoto(targetLatitude, targetLongitude);
                                }
                            }
                        }
                        else if (e.Button == MouseButtons.Right)
                        {
                            if (this.isMouseDragging)
                                this.isMouseDragging = false;
                            else
                            {
                                if (!m_World.PerformSelectionAction(this.drawArgs))
                                {
                                    //nothing at the moment
                                }
                            }
                        }
                    }
				}
			}
			finally
			{
				if(e.Button == MouseButtons.Left)
					DrawArgs.IsLeftMouseButtonDown = false;

				if(e.Button == MouseButtons.Right)
					DrawArgs.IsRightMouseButtonDown = false;
				// Call the base class method so that registered delegates receive the event.
				base.OnMouseUp(e);
			}
		}

		protected override void OnMouseMove(MouseEventArgs e)
		{
			// Default to default cursor
			DrawArgs.MouseCursor = CursorType.Arrow;

			try
			{
				bool handled = false;
                if (!isMouseDragging)
                {
                    handled = m_RootWidget.OnMouseMove(e);

                    if (!handled)
                    {
                        handled = m_NewRootWidget.OnMouseMove(e);
                    }
                }

				if(!handled)
				{
					int deltaX = e.X - DrawArgs.LastMousePosition.X;
					int deltaY = e.Y - DrawArgs.LastMousePosition.Y;
					float deltaXNormalized = (float)deltaX/drawArgs.screenWidth;
					float deltaYNormalized = (float)deltaY/drawArgs.screenHeight;

					if(!this.isMouseDragging)
					{
						if(this._menuBar.OnMouseMove(e))
						{
							base.OnMouseMove(e);
							return;
						}
					}

					if(mouseDownStartPosition == Point.Empty)
						return;

					bool isMouseLeftButtonDown = ((int)e.Button & (int)MouseButtons.Left) != 0;
					bool isMouseRightButtonDown = ((int)e.Button & (int)MouseButtons.Right) != 0;
					if (isMouseLeftButtonDown || isMouseRightButtonDown)
					{
						int dx = this.mouseDownStartPosition.X - e.X;
						int dy = this.mouseDownStartPosition.Y - e.Y;
						int distanceSquared = dx*dx + dy*dy;
						if (distanceSquared > 3*3)
							// Distance > 3 = drag
							this.isMouseDragging = true;
					}

					if (isMouseLeftButtonDown && !isMouseRightButtonDown)
					{
						// Left button (pan)
						// Store start lat/lon for drag
						Angle prevLat, prevLon;
						this.drawArgs.WorldCamera.PickingRayIntersection(
							DrawArgs.LastMousePosition.X,
							DrawArgs.LastMousePosition.Y,
							out prevLat,
							out prevLon);

						Angle curLat, curLon;
						this.drawArgs.WorldCamera.PickingRayIntersection(
							e.X,
							e.Y,
							out curLat,
							out curLon);

						if(World.Settings.CameraTwistLock)
						{
							if(Angle.IsNaN(curLat)||Angle.IsNaN(prevLat))
							{
								// Old style pan
								Angle deltaLat = Angle.FromRadians((double)deltaY * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
								Angle deltaLon = Angle.FromRadians((double)-deltaX * (this.drawArgs.WorldCamera.Altitude) / (800 * this.CurrentWorld.EquatorialRadius));
								this.drawArgs.WorldCamera.Pan(deltaLat, deltaLon);
							}
							else
							{
								//Picking ray pan
								Angle lat = prevLat-curLat;
								Angle lon = prevLon-curLon;
								this.drawArgs.WorldCamera.Pan( lat, lon );
							}
						}
						else
						{
							double factor =  (this.drawArgs.WorldCamera.Altitude) / (1500 * this.CurrentWorld.EquatorialRadius);
							drawArgs.WorldCamera.RotationYawPitchRoll(
								Angle.FromRadians(DrawArgs.LastMousePosition.X-e.X)*factor,
								Angle.FromRadians(e.Y-DrawArgs.LastMousePosition.Y)*factor,
								Angle.Zero);
						}
					}
					else if (!isMouseLeftButtonDown && isMouseRightButtonDown)
					{
						//Right mouse button

						// Heading
						Angle deltaEyeDirection = Angle.FromRadians( -deltaXNormalized * World.Settings.CameraRotationSpeed);
						this.drawArgs.WorldCamera.RotationYawPitchRoll( Angle.Zero, Angle.Zero, deltaEyeDirection );

						// tilt
						this.drawArgs.WorldCamera.Tilt += Angle.FromRadians(deltaYNormalized * World.Settings.CameraRotationSpeed );
					}
					else if (isMouseLeftButtonDown && isMouseRightButtonDown)
					{
						// Both buttons (zoom)
						if(Math.Abs(deltaYNormalized) > float.Epsilon)
							this.drawArgs.WorldCamera.Zoom( -deltaYNormalized*World.Settings.CameraZoomAnalogFactor );

						if (!World.Settings.CameraBankLock)
							this.drawArgs.WorldCamera.Bank -= Angle.FromRadians( deltaXNormalized * World.Settings.CameraRotationSpeed );
					}
				}
			}
			catch
			{
			}
			finally
			{

				this.drawArgs.WorldCamera.PickingRayIntersection(
					e.X,
					e.Y,
					out cLat,
					out cLon);

				DrawArgs.LastMousePosition.X = e.X;
				DrawArgs.LastMousePosition.Y = e.Y;
				base.OnMouseMove(e);
			}
		}

		Angle cLat, cLon;

		protected override void OnMouseLeave(EventArgs e)
		{
			if(_menuBar!=null)
				// reset menu bar mouse hover state.
				_menuBar.OnMouseMove(new MouseEventArgs(MouseButtons.None, 0,-1,-1,0));
			base.OnMouseLeave(e);
		}

		#endregion

		protected void SaveScreenShot()
		{
			try
			{
				using( Surface backbuffer = m_Device3d.GetBackBuffer(0, 0, BackBufferType.Mono) )
					SurfaceLoader.Save(saveScreenShotFilePath, saveScreenShotImageFileFormat, backbuffer);
				saveScreenShotFilePath = null;
			}
			catch(InvalidCallException caught)
			{
				MessageBox.Show(caught.Message, "Screenshot save failed.", MessageBoxButtons.OK, MessageBoxIcon.Error );
			}
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(m_WorkerThread != null && m_WorkerThread.IsAlive)
				{
					m_WorkerThreadRunning = false;
					m_WorkerThread.Abort();
				}

				m_FpsTimer.Stop();
				if(m_World != null)
				{
					m_World.Dispose();
					m_World = null;
				}
				if(this.drawArgs != null)
				{
					this.drawArgs.Dispose();
					this.drawArgs = null;
				}
				if(this._menuBar!=null)
				{
					this._menuBar.Dispose();
					this._menuBar = null;
				}

				m_Device3d.Dispose();
/*
				if(m_downloadIndicator != null)
				{
					m_downloadIndicator.Dispose();
					m_downloadIndicator = null;
				}
*/				
			}

			base.Dispose( disposing );
			GC.SuppressFinalize(this);
		}

		private void m_Device3d_DeviceResizing(object sender, CancelEventArgs e)
		{
			if(this.Size.Width == 0 || this.Size.Height == 0)
			{
				e.Cancel = true;
				return;
			}

			this.drawArgs.screenHeight = this.Height;
			this.drawArgs.screenWidth = this.Width;
		}


		/// <summary>
		/// Returns true if executing in Design mode (inside IDE)
		/// </summary>
		/// <returns></returns>
		private static bool IsInDesignMode()
		{
			return Application.ExecutablePath.ToUpper(CultureInfo.InvariantCulture).EndsWith("DEVENV.EXE");
		}

		private void InitializeGraphics()
		{
			// Set up our presentation parameters
			m_presentParams = new PresentParameters();

			m_presentParams.Windowed = true;
			m_presentParams.SwapEffect = SwapEffect.Discard;
			m_presentParams.AutoDepthStencilFormat = DepthFormat.D16;
			m_presentParams.EnableAutoDepthStencil = true;
			
			if(!World.Settings.VSync)
				// Disable wait for vertical retrace (higher frame rate at the expense of tearing)
				m_presentParams.PresentationInterval = PresentInterval.Immediate;

			int adapterOrdinal = 0;
			try
			{
				// Store the default adapter
				adapterOrdinal = Manager.Adapters.Default.Adapter;
			}
			catch
			{
				// User probably needs to upgrade DirectX or install a 3D capable graphics adapter
				throw new NotAvailableException();
			}

			DeviceType dType = DeviceType.Hardware;

			foreach(AdapterInformation ai in Manager.Adapters)
			{
				if(ai.Information.Description.IndexOf("NVPerfHUD") >= 0)
				{
					adapterOrdinal = ai.Adapter;
					dType = DeviceType.Reference;
				}
			}
			CreateFlags flags = CreateFlags.SoftwareVertexProcessing;

			// Check to see if we can use a pure hardware m_Device3d
			Caps caps = Manager.GetDeviceCaps(adapterOrdinal, DeviceType.Hardware);

			// Do we support hardware vertex processing?
			if(caps.DeviceCaps.SupportsHardwareTransformAndLight)
				//	// Replace the software vertex processing
				flags = CreateFlags.HardwareVertexProcessing;

			// Use multi-threading for now - TODO: See if the code can be changed such that this isn't necessary (Texture Loading for example)
			flags |= CreateFlags.MultiThreaded | CreateFlags.FpuPreserve;

			try
			{
				// Create our m_Device3d
				m_Device3d = new Device(adapterOrdinal, dType, this, flags, m_presentParams);
			}
			catch( Microsoft.DirectX.DirectXException	)
			{
				throw new NotSupportedException("Unable to create the Direct3D m_Device3d.");
			}

			// Hook the m_Device3d reset event
			m_Device3d.DeviceReset += new EventHandler(OnDeviceReset);
			m_Device3d.DeviceResizing += new CancelEventHandler(m_Device3d_DeviceResizing);
			OnDeviceReset(m_Device3d, null);
		}

		private void OnDeviceReset(object sender, EventArgs e)
		{
			// Can we use anisotropic texture minify filter?
			if( m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyAnisotropic)
			{
				m_Device3d.SamplerState[0].MinFilter = TextureFilter.Anisotropic;
			}
			else if( m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMinifyLinear)
			{
				m_Device3d.SamplerState[0].MinFilter = TextureFilter.Linear;
			}

			// What about magnify filter?
			if( m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyAnisotropic )
			{
				m_Device3d.SamplerState[0].MagFilter = TextureFilter.Anisotropic;
			}
			else if( m_Device3d.DeviceCaps.TextureFilterCaps.SupportsMagnifyLinear )
			{
				m_Device3d.SamplerState[0].MagFilter = TextureFilter.Linear;
			}

			m_Device3d.SamplerState[0].AddressU = TextureAddress.Clamp;
			m_Device3d.SamplerState[0].AddressV = TextureAddress.Clamp;

			m_Device3d.RenderState.Clipping = true;
			m_Device3d.RenderState.CullMode = Cull.Clockwise;
			m_Device3d.RenderState.Lighting = false;
			m_Device3d.RenderState.Ambient = World.Settings.StandardAmbientColor;

			m_Device3d.RenderState.ZBufferEnable = true;
			m_Device3d.RenderState.AlphaBlendEnable = true;
			m_Device3d.RenderState.SourceBlend = Blend.SourceAlpha;
			m_Device3d.RenderState.DestinationBlend = Blend.InvSourceAlpha;
		}

		/// <summary>
		/// Background worker thread loop (updates UI)
		/// </summary>
		private void WorkerThreadFunc()
		{
			const int refreshIntervalMs = 150; // Max 6 updates per seconds
			while(m_WorkerThreadRunning)
			{
				try
				{
					if(World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.Normal)
					{
						m_WorkerThread.Priority = System.Threading.ThreadPriority.BelowNormal;
					}
					else if(!World.Settings.UseBelowNormalPriorityUpdateThread && m_WorkerThread.Priority == System.Threading.ThreadPriority.BelowNormal)
					{
						m_WorkerThread.Priority = System.Threading.ThreadPriority.Normal;
					}

					long startTicks = 0;
					PerformanceTimer.QueryPerformanceCounter(ref startTicks);

					m_World.Update(this.drawArgs);

					long endTicks = 0;
					PerformanceTimer.QueryPerformanceCounter(ref endTicks);
					float elapsedMilliSeconds = 1000*(float)(endTicks - startTicks)/PerformanceTimer.TicksPerSecond;
					float remaining = refreshIntervalMs - elapsedMilliSeconds;
					if(remaining > 0)
						Thread.Sleep((int)remaining);
				}
				catch(Exception caught)
				{
					Log.Write(caught);
				}
			}
		}

		#region IGlobe Members

		public void SetDisplayMessages(IList messages)
		{
			m_World.OnScreenMessages = messages;
		}

		public void SetLatLonGridShow(bool show)
		{
			World.Settings.ShowLatLonLines = show;
		}

		public void SetLayers(IList layers)
		{
			if (layers != null)
			{
				foreach (LayerDescriptor ld in layers)
				{
					this.CurrentWorld.SetLayerOpacity(ld.Category, ld.Name, (float)ld.Opacity * 0.01f);
				}
			}
		}

		public void SetVerticalExaggeration(double exageration)
		{
			World.Settings.VerticalExaggeration = (float)exageration;
		}

		public void SetViewDirection(String type, double horiz, double vert, double elev)
		{
			this.drawArgs.WorldCamera.SetPosition(this.drawArgs.WorldCamera.Latitude.Degrees, this.drawArgs.WorldCamera.Longitude.Degrees, horiz,
				this.drawArgs.WorldCamera.Altitude, vert);
		}

		public void SetViewPosition(double degreesLatitude, double degreesLongitude,
			double metersElevation)
		{
			this.drawArgs.WorldCamera.SetPosition(degreesLatitude, degreesLongitude, this.drawArgs.WorldCamera.Heading.Degrees,
				metersElevation, this.drawArgs.WorldCamera.Tilt.Degrees);
		}

		public void SetWmsImage(WmsDescriptor imageA, WmsDescriptor imageB, double alpha)
		{
			// TODO:  Add WorldWindow.SetWmsImage implementation
			if (imageA != null)
			{
				// TODO: Remove writes to console once Wms images are implemented.
				System.Console.Write(imageA.Url.ToString() + " ");
				System.Console.WriteLine(imageA.Opacity);
			}
			if (imageB != null)
			{
				// TODO: Remove writes to console once Wms images are implemented.
				System.Console.Write(imageB.Url.ToString() + " ");
				System.Console.Write(imageB.Opacity);
				System.Console.Write(" alpha = ");
				System.Console.WriteLine(alpha);
			}
		}

		#endregion

		bool m_FpsUpdate = false;
		private void m_FpsTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
		{
			if(m_FpsUpdate)
				return;

			m_FpsUpdate = true;
				
			try
			{
				if(World.Settings.ShowFpsGraph)
				{
					if(!m_FpsGraph.Visible)
					{
						m_FpsGraph.Visible = true;
					}
					
					if(m_FrameTimes.Count > World.Settings.FpsFrameCount)
					{
						m_FrameTimes.RemoveRange(0, m_FrameTimes.Count - World.Settings.FpsFrameCount);
					}
					
					m_FpsGraph.Size = new Size((int)(Width * .5), (int)(Height * .1));
					m_FpsGraph.Location = new Point((int)(Width * .35), (int)(Height * .895));
					m_FpsGraph.Values = (float[])m_FrameTimes.ToArray(typeof(float));
				}
				else
				{
					if(m_FpsGraph.Visible)
					{
						m_FpsGraph.Visible = false;
					}
				}
			}
			catch(Exception ex)
			{
				Log.Write(ex);
			}

			m_FpsUpdate = false;
		}
	}
}
